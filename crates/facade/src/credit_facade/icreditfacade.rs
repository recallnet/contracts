/**

Generated by the following Solidity interface...
```solidity
interface ICreditFacade {
    struct Account {
        uint64 capacityUsed;
        uint256 creditFree;
        uint256 creditCommitted;
        address creditSponsor;
        uint64 lastDebitEpoch;
        Approval[] approvalsTo;
        Approval[] approvalsFrom;
        uint64 maxTtl;
        uint256 gasAllowance;
    }
    struct Approval {
        address addr;
        CreditApproval approval;
    }
    struct Balance {
        uint256 creditFree;
        uint256 creditCommitted;
        address creditSponsor;
        uint64 lastDebitEpoch;
        Approval[] approvalsTo;
        Approval[] approvalsFrom;
        uint256 gasAllowance;
    }
    struct CreditApproval {
        uint256 creditLimit;
        uint256 gasFeeLimit;
        uint64 expiry;
        uint256 creditUsed;
        uint256 gasFeeUsed;
    }
    struct CreditStats {
        uint256 balance;
        uint256 creditSold;
        uint256 creditCommitted;
        uint256 creditDebited;
        uint256 tokenCreditRate;
        uint64 numAccounts;
    }

    event CreditApproved(address from, address to, uint256 creditLimit, uint256 gasFeeLimit, uint256 expiry);
    event CreditDebited(uint256 amount, uint256 numAccounts, bool moreAccounts);
    event CreditPurchased(address from, uint256 amount);
    event CreditRevoked(address from, address to);

    function approveCredit(address to) external;
    function approveCredit(address from, address to, address[] memory caller) external;
    function approveCredit(address from, address to, address[] memory caller, uint256 creditLimit, uint256 gasFeeLimit, uint64 ttl) external;
    function approveCredit(address from, address to) external;
    function buyCredit() external payable;
    function buyCredit(address recipient) external payable;
    function getAccount(address addr) external view returns (Account memory account);
    function getCreditApproval(address from, address to) external view returns (CreditApproval memory approval);
    function getCreditBalance(address addr) external view returns (Balance memory balance);
    function getCreditStats() external view returns (CreditStats memory stats);
    function revokeCredit(address from, address to) external;
    function revokeCredit(address to) external;
    function revokeCredit(address from, address to, address caller) external;
    function setAccountSponsor(address from, address sponsor) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "approveCredit",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "approveCredit",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "caller",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "approveCredit",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "caller",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "creditLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "gasFeeLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "ttl",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "approveCredit",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "buyCredit",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "buyCredit",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getAccount",
    "inputs": [
      {
        "name": "addr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "account",
        "type": "tuple",
        "internalType": "struct Account",
        "components": [
          {
            "name": "capacityUsed",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "creditFree",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditCommitted",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditSponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "lastDebitEpoch",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "approvalsTo",
            "type": "tuple[]",
            "internalType": "struct Approval[]",
            "components": [
              {
                "name": "addr",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "approval",
                "type": "tuple",
                "internalType": "struct CreditApproval",
                "components": [
                  {
                    "name": "creditLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "expiry",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "creditUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          },
          {
            "name": "approvalsFrom",
            "type": "tuple[]",
            "internalType": "struct Approval[]",
            "components": [
              {
                "name": "addr",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "approval",
                "type": "tuple",
                "internalType": "struct CreditApproval",
                "components": [
                  {
                    "name": "creditLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "expiry",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "creditUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          },
          {
            "name": "maxTtl",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "gasAllowance",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCreditApproval",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "approval",
        "type": "tuple",
        "internalType": "struct CreditApproval",
        "components": [
          {
            "name": "creditLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "gasFeeLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expiry",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "creditUsed",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "gasFeeUsed",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCreditBalance",
    "inputs": [
      {
        "name": "addr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "balance",
        "type": "tuple",
        "internalType": "struct Balance",
        "components": [
          {
            "name": "creditFree",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditCommitted",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditSponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "lastDebitEpoch",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "approvalsTo",
            "type": "tuple[]",
            "internalType": "struct Approval[]",
            "components": [
              {
                "name": "addr",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "approval",
                "type": "tuple",
                "internalType": "struct CreditApproval",
                "components": [
                  {
                    "name": "creditLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "expiry",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "creditUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          },
          {
            "name": "approvalsFrom",
            "type": "tuple[]",
            "internalType": "struct Approval[]",
            "components": [
              {
                "name": "addr",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "approval",
                "type": "tuple",
                "internalType": "struct CreditApproval",
                "components": [
                  {
                    "name": "creditLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeLimit",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "expiry",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "creditUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "gasFeeUsed",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          },
          {
            "name": "gasAllowance",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCreditStats",
    "inputs": [],
    "outputs": [
      {
        "name": "stats",
        "type": "tuple",
        "internalType": "struct CreditStats",
        "components": [
          {
            "name": "balance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditSold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditCommitted",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "creditDebited",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "tokenCreditRate",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "numAccounts",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revokeCredit",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeCredit",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeCredit",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAccountSponsor",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "sponsor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "CreditApproved",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "creditLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "gasFeeLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CreditDebited",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "numAccounts",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "moreAccounts",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CreditPurchased",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CreditRevoked",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ICreditFacade {
    use super::*;
    use ::alloy_sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /**```solidity
struct Account { uint64 capacityUsed; uint256 creditFree; uint256 creditCommitted; address creditSponsor; uint64 lastDebitEpoch; Approval[] approvalsTo; Approval[] approvalsFrom; uint64 maxTtl; uint256 gasAllowance; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Account {
        #[allow(missing_docs)]
        pub capacityUsed: u64,
        #[allow(missing_docs)]
        pub creditFree: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditCommitted: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditSponsor: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub lastDebitEpoch: u64,
        #[allow(missing_docs)]
        pub approvalsTo: ::alloy_sol_types::private::Vec<
            <Approval as ::alloy_sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub approvalsFrom: ::alloy_sol_types::private::Vec<
            <Approval as ::alloy_sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub maxTtl: u64,
        #[allow(missing_docs)]
        pub gasAllowance: ::alloy_sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<64>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Address,
            ::alloy_sol_types::sol_data::Uint<64>,
            ::alloy_sol_types::sol_data::Array<Approval>,
            ::alloy_sol_types::sol_data::Array<Approval>,
            ::alloy_sol_types::sol_data::Uint<64>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::Address,
            u64,
            ::alloy_sol_types::private::Vec<
                <Approval as ::alloy_sol_types::SolType>::RustType,
            >,
            ::alloy_sol_types::private::Vec<
                <Approval as ::alloy_sol_types::SolType>::RustType,
            >,
            u64,
            ::alloy_sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Account> for UnderlyingRustTuple<'_> {
            fn from(value: Account) -> Self {
                (
                    value.capacityUsed,
                    value.creditFree,
                    value.creditCommitted,
                    value.creditSponsor,
                    value.lastDebitEpoch,
                    value.approvalsTo,
                    value.approvalsFrom,
                    value.maxTtl,
                    value.gasAllowance,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Account {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    capacityUsed: tuple.0,
                    creditFree: tuple.1,
                    creditCommitted: tuple.2,
                    creditSponsor: tuple.3,
                    lastDebitEpoch: tuple.4,
                    approvalsTo: tuple.5,
                    approvalsFrom: tuple.6,
                    maxTtl: tuple.7,
                    gasAllowance: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Account {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Account {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.capacityUsed),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditFree),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditCommitted),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.creditSponsor,
                    ),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastDebitEpoch),
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::tokenize(&self.approvalsTo),
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::tokenize(&self.approvalsFrom),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxTtl),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasAllowance),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Account {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Account {
            const NAME: &'static str = "Account";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Account(uint64 capacityUsed,uint256 creditFree,uint256 creditCommitted,address creditSponsor,uint64 lastDebitEpoch,Approval[] approvalsTo,Approval[] approvalsFrom,uint64 maxTtl,uint256 gasAllowance)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components
                    .push(<Approval as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Approval as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(<Approval as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Approval as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.capacityUsed)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditFree)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.creditCommitted,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.creditSponsor,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.lastDebitEpoch,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.approvalsTo)
                        .0,
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.approvalsFrom)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.maxTtl)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasAllowance)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Account {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.capacityUsed,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditFree,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditCommitted,
                    )
                    + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditSponsor,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastDebitEpoch,
                    )
                    + <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approvalsTo,
                    )
                    + <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approvalsFrom,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxTtl,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasAllowance,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.capacityUsed,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditFree,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditCommitted,
                    out,
                );
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditSponsor,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastDebitEpoch,
                    out,
                );
                <::alloy_sol_types::sol_data::Array<
                    Approval,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approvalsTo,
                    out,
                );
                <::alloy_sol_types::sol_data::Array<
                    Approval,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approvalsFrom,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxTtl,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasAllowance,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Approval { address addr; CreditApproval approval; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub addr: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub approval: <CreditApproval as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Address,
            CreditApproval,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Address,
            <CreditApproval as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Approval> for UnderlyingRustTuple<'_> {
            fn from(value: Approval) -> Self {
                (value.addr, value.approval)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Approval {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    approval: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Approval {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Approval {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <CreditApproval as alloy_sol_types::SolType>::tokenize(
                        &self.approval,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Approval {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Approval {
            const NAME: &'static str = "Approval";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Approval(address addr,CreditApproval approval)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <CreditApproval as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <CreditApproval as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <CreditApproval as alloy_sol_types::SolType>::eip712_data_word(
                            &self.approval,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Approval {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <CreditApproval as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approval,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <CreditApproval as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approval,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Balance { uint256 creditFree; uint256 creditCommitted; address creditSponsor; uint64 lastDebitEpoch; Approval[] approvalsTo; Approval[] approvalsFrom; uint256 gasAllowance; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Balance {
        #[allow(missing_docs)]
        pub creditFree: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditCommitted: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditSponsor: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub lastDebitEpoch: u64,
        #[allow(missing_docs)]
        pub approvalsTo: ::alloy_sol_types::private::Vec<
            <Approval as ::alloy_sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub approvalsFrom: ::alloy_sol_types::private::Vec<
            <Approval as ::alloy_sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub gasAllowance: ::alloy_sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Address,
            ::alloy_sol_types::sol_data::Uint<64>,
            ::alloy_sol_types::sol_data::Array<Approval>,
            ::alloy_sol_types::sol_data::Array<Approval>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::Address,
            u64,
            ::alloy_sol_types::private::Vec<
                <Approval as ::alloy_sol_types::SolType>::RustType,
            >,
            ::alloy_sol_types::private::Vec<
                <Approval as ::alloy_sol_types::SolType>::RustType,
            >,
            ::alloy_sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Balance> for UnderlyingRustTuple<'_> {
            fn from(value: Balance) -> Self {
                (
                    value.creditFree,
                    value.creditCommitted,
                    value.creditSponsor,
                    value.lastDebitEpoch,
                    value.approvalsTo,
                    value.approvalsFrom,
                    value.gasAllowance,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Balance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    creditFree: tuple.0,
                    creditCommitted: tuple.1,
                    creditSponsor: tuple.2,
                    lastDebitEpoch: tuple.3,
                    approvalsTo: tuple.4,
                    approvalsFrom: tuple.5,
                    gasAllowance: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Balance {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Balance {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditFree),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditCommitted),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.creditSponsor,
                    ),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastDebitEpoch),
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::tokenize(&self.approvalsTo),
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::tokenize(&self.approvalsFrom),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasAllowance),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Balance {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Balance {
            const NAME: &'static str = "Balance";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Balance(uint256 creditFree,uint256 creditCommitted,address creditSponsor,uint64 lastDebitEpoch,Approval[] approvalsTo,Approval[] approvalsFrom,uint256 gasAllowance)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components
                    .push(<Approval as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Approval as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(<Approval as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Approval as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditFree)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.creditCommitted,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.creditSponsor,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.lastDebitEpoch,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.approvalsTo)
                        .0,
                    <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.approvalsFrom)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasAllowance)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Balance {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditFree,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditCommitted,
                    )
                    + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditSponsor,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastDebitEpoch,
                    )
                    + <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approvalsTo,
                    )
                    + <::alloy_sol_types::sol_data::Array<
                        Approval,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approvalsFrom,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasAllowance,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditFree,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditCommitted,
                    out,
                );
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditSponsor,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastDebitEpoch,
                    out,
                );
                <::alloy_sol_types::sol_data::Array<
                    Approval,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approvalsTo,
                    out,
                );
                <::alloy_sol_types::sol_data::Array<
                    Approval,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approvalsFrom,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasAllowance,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct CreditApproval { uint256 creditLimit; uint256 gasFeeLimit; uint64 expiry; uint256 creditUsed; uint256 gasFeeUsed; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CreditApproval {
        #[allow(missing_docs)]
        pub creditLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub gasFeeLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: u64,
        #[allow(missing_docs)]
        pub creditUsed: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub gasFeeUsed: ::alloy_sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<64>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            u64,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CreditApproval> for UnderlyingRustTuple<'_> {
            fn from(value: CreditApproval) -> Self {
                (
                    value.creditLimit,
                    value.gasFeeLimit,
                    value.expiry,
                    value.creditUsed,
                    value.gasFeeUsed,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CreditApproval {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    creditLimit: tuple.0,
                    gasFeeLimit: tuple.1,
                    expiry: tuple.2,
                    creditUsed: tuple.3,
                    gasFeeUsed: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CreditApproval {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CreditApproval {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasFeeLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditUsed),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasFeeUsed),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CreditApproval {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CreditApproval {
            const NAME: &'static str = "CreditApproval";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CreditApproval(uint256 creditLimit,uint256 gasFeeLimit,uint64 expiry,uint256 creditUsed,uint256 gasFeeUsed)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditLimit)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasFeeLimit)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expiry)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditUsed)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasFeeUsed)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CreditApproval {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditLimit,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasFeeLimit,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expiry,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditUsed,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasFeeUsed,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditLimit,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasFeeLimit,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expiry,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditUsed,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasFeeUsed,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct CreditStats { uint256 balance; uint256 creditSold; uint256 creditCommitted; uint256 creditDebited; uint256 tokenCreditRate; uint64 numAccounts; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CreditStats {
        #[allow(missing_docs)]
        pub balance: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditSold: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditCommitted: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creditDebited: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tokenCreditRate: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numAccounts: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            ::alloy_sol_types::private::primitives::aliases::U256,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CreditStats> for UnderlyingRustTuple<'_> {
            fn from(value: CreditStats) -> Self {
                (
                    value.balance,
                    value.creditSold,
                    value.creditCommitted,
                    value.creditDebited,
                    value.tokenCreditRate,
                    value.numAccounts,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CreditStats {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    creditSold: tuple.1,
                    creditCommitted: tuple.2,
                    creditDebited: tuple.3,
                    tokenCreditRate: tuple.4,
                    numAccounts: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CreditStats {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CreditStats {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditSold),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditCommitted),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditDebited),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenCreditRate),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.numAccounts),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CreditStats {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CreditStats {
            const NAME: &'static str = "CreditStats";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CreditStats(uint256 balance,uint256 creditSold,uint256 creditCommitted,uint256 creditDebited,uint256 tokenCreditRate,uint64 numAccounts)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.balance)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditSold)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.creditCommitted,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.creditDebited)
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tokenCreditRate,
                        )
                        .0,
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.numAccounts)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CreditStats {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.balance,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditSold,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditCommitted,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.creditDebited,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tokenCreditRate,
                    )
                    + <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numAccounts,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.balance,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditSold,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditCommitted,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.creditDebited,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tokenCreditRate,
                    out,
                );
                <::alloy_sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numAccounts,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `CreditApproved(address,address,uint256,uint256,uint256)` and selector `0xc69709e6f767dad7ccb19c605c3c602bf482ecb426059d7cdb5e5737d05b22f8`.
```solidity
event CreditApproved(address from, address to, uint256 creditLimit, uint256 gasFeeLimit, uint256 expiry);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CreditApproved {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub creditLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub gasFeeLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: ::alloy_sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CreditApproved {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CreditApproved(address,address,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                198u8,
                151u8,
                9u8,
                230u8,
                247u8,
                103u8,
                218u8,
                215u8,
                204u8,
                177u8,
                156u8,
                96u8,
                92u8,
                60u8,
                96u8,
                43u8,
                244u8,
                130u8,
                236u8,
                180u8,
                38u8,
                5u8,
                157u8,
                124u8,
                219u8,
                94u8,
                87u8,
                55u8,
                208u8,
                91u8,
                34u8,
                248u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: data.0,
                    to: data.1,
                    creditLimit: data.2,
                    gasFeeLimit: data.3,
                    expiry: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasFeeLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CreditApproved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CreditApproved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CreditApproved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CreditDebited(uint256,uint256,bool)` and selector `0x5cc1b5286143c9d1f8e1c090b5d7302388ab94fb45b1e18e63d8b08ef8c0f7c3`.
```solidity
event CreditDebited(uint256 amount, uint256 numAccounts, bool moreAccounts);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CreditDebited {
        #[allow(missing_docs)]
        pub amount: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numAccounts: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub moreAccounts: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CreditDebited {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Bool,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CreditDebited(uint256,uint256,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                92u8,
                193u8,
                181u8,
                40u8,
                97u8,
                67u8,
                201u8,
                209u8,
                248u8,
                225u8,
                192u8,
                144u8,
                181u8,
                215u8,
                48u8,
                35u8,
                136u8,
                171u8,
                148u8,
                251u8,
                69u8,
                177u8,
                225u8,
                142u8,
                99u8,
                216u8,
                176u8,
                142u8,
                248u8,
                192u8,
                247u8,
                195u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    amount: data.0,
                    numAccounts: data.1,
                    moreAccounts: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numAccounts),
                    <::alloy_sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.moreAccounts,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CreditDebited {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CreditDebited> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CreditDebited) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CreditPurchased(address,uint256)` and selector `0xacf2bdc99696da35cbfe300e8b7d3d337ffc9918d8547c58ef8b58a20ec075df`.
```solidity
event CreditPurchased(address from, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CreditPurchased {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: ::alloy_sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CreditPurchased {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CreditPurchased(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                172u8,
                242u8,
                189u8,
                201u8,
                150u8,
                150u8,
                218u8,
                53u8,
                203u8,
                254u8,
                48u8,
                14u8,
                139u8,
                125u8,
                61u8,
                51u8,
                127u8,
                252u8,
                153u8,
                24u8,
                216u8,
                84u8,
                124u8,
                88u8,
                239u8,
                139u8,
                88u8,
                162u8,
                14u8,
                192u8,
                117u8,
                223u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: data.0,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CreditPurchased {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CreditPurchased> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CreditPurchased) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CreditRevoked(address,address)` and selector `0xe63d1a905c0cbc7f25c8f71af5ecb744b771b20f954f39e1654d4d838f93b89e`.
```solidity
event CreditRevoked(address from, address to);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CreditRevoked {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CreditRevoked {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CreditRevoked(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                230u8,
                61u8,
                26u8,
                144u8,
                92u8,
                12u8,
                188u8,
                127u8,
                37u8,
                200u8,
                247u8,
                26u8,
                245u8,
                236u8,
                183u8,
                68u8,
                183u8,
                113u8,
                178u8,
                15u8,
                149u8,
                79u8,
                57u8,
                225u8,
                101u8,
                77u8,
                77u8,
                131u8,
                143u8,
                147u8,
                184u8,
                158u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { from: data.0, to: data.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CreditRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CreditRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CreditRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `approveCredit(address)` and selector `0x01e98bfa`.
```solidity
function approveCredit(address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_0Call {
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`approveCredit(address)`](approveCredit_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_0Call) -> Self {
                    (value.to,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCredit_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { to: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveCredit_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCredit_0Call {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveCredit_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveCredit(address)";
            const SELECTOR: [u8; 4] = [1u8, 233u8, 139u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approveCredit(address,address,address[])` and selector `0x030ed548`.
```solidity
function approveCredit(address from, address to, address[] memory caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_1Call {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub caller: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`approveCredit(address,address,address[])`](approveCredit_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_1Call) -> Self {
                    (value.from, value.to, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCredit_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        caller: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveCredit_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCredit_1Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveCredit_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveCredit(address,address,address[])";
            const SELECTOR: [u8; 4] = [3u8, 14u8, 213u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <::alloy_sol_types::sol_data::Array<
                        ::alloy_sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.caller),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approveCredit(address,address,address[],uint256,uint256,uint64)` and selector `0xb27d8c02`.
```solidity
function approveCredit(address from, address to, address[] memory caller, uint256 creditLimit, uint256 gasFeeLimit, uint64 ttl) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_2Call {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub caller: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        #[allow(missing_docs)]
        pub creditLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub gasFeeLimit: ::alloy_sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub ttl: u64,
    }
    ///Container type for the return parameters of the [`approveCredit(address,address,address[],uint256,uint256,uint64)`](approveCredit_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_2Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
                ::alloy_sol_types::private::primitives::aliases::U256,
                ::alloy_sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_2Call) -> Self {
                    (
                        value.from,
                        value.to,
                        value.caller,
                        value.creditLimit,
                        value.gasFeeLimit,
                        value.ttl,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCredit_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        caller: tuple.2,
                        creditLimit: tuple.3,
                        gasFeeLimit: tuple.4,
                        ttl: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveCredit_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCredit_2Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveCredit_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveCredit(address,address,address[],uint256,uint256,uint64)";
            const SELECTOR: [u8; 4] = [178u8, 125u8, 140u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <::alloy_sol_types::sol_data::Array<
                        ::alloy_sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.caller),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.creditLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasFeeLimit),
                    <::alloy_sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approveCredit(address,address)` and selector `0xf1d6ed64`.
```solidity
function approveCredit(address from, address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_3Call {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`approveCredit(address,address)`](approveCredit_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCredit_3Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_3Call) -> Self {
                    (value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCredit_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCredit_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveCredit_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveCredit_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCredit_3Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveCredit_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveCredit(address,address)";
            const SELECTOR: [u8; 4] = [241u8, 214u8, 237u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `buyCredit()` and selector `0x8e4e6f06`.
```solidity
function buyCredit() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct buyCredit_0Call {}
    ///Container type for the return parameters of the [`buyCredit()`](buyCredit_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct buyCredit_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<buyCredit_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: buyCredit_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for buyCredit_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<buyCredit_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: buyCredit_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for buyCredit_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for buyCredit_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = buyCredit_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "buyCredit()";
            const SELECTOR: [u8; 4] = [142u8, 78u8, 111u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `buyCredit(address)` and selector `0xa38eae9f`.
```solidity
function buyCredit(address recipient) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct buyCredit_1Call {
        #[allow(missing_docs)]
        pub recipient: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`buyCredit(address)`](buyCredit_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct buyCredit_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<buyCredit_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: buyCredit_1Call) -> Self {
                    (value.recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for buyCredit_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<buyCredit_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: buyCredit_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for buyCredit_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for buyCredit_1Call {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = buyCredit_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "buyCredit(address)";
            const SELECTOR: [u8; 4] = [163u8, 142u8, 174u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAccount(address)` and selector `0xfbcbc0f1`.
```solidity
function getAccount(address addr) external view returns (Account memory account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAccountCall {
        #[allow(missing_docs)]
        pub addr: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAccount(address)`](getAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAccountReturn {
        #[allow(missing_docs)]
        pub account: <Account as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAccountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAccountCall) -> Self {
                    (value.addr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { addr: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Account,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Account as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAccountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAccountReturn) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAccountCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAccountReturn;
            type ReturnTuple<'a> = (Account,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAccount(address)";
            const SELECTOR: [u8; 4] = [251u8, 203u8, 192u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCreditApproval(address,address)` and selector `0xcd9be80f`.
```solidity
function getCreditApproval(address from, address to) external view returns (CreditApproval memory approval);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditApprovalCall {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getCreditApproval(address,address)`](getCreditApprovalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditApprovalReturn {
        #[allow(missing_docs)]
        pub approval: <CreditApproval as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditApprovalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCreditApprovalCall) -> Self {
                    (value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCreditApprovalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CreditApproval,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <CreditApproval as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditApprovalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCreditApprovalReturn) -> Self {
                    (value.approval,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCreditApprovalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { approval: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCreditApprovalCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCreditApprovalReturn;
            type ReturnTuple<'a> = (CreditApproval,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCreditApproval(address,address)";
            const SELECTOR: [u8; 4] = [205u8, 155u8, 232u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCreditBalance(address)` and selector `0x6add1b3f`.
```solidity
function getCreditBalance(address addr) external view returns (Balance memory balance);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditBalanceCall {
        #[allow(missing_docs)]
        pub addr: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getCreditBalance(address)`](getCreditBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditBalanceReturn {
        #[allow(missing_docs)]
        pub balance: <Balance as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCreditBalanceCall) -> Self {
                    (value.addr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCreditBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { addr: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Balance,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Balance as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCreditBalanceReturn) -> Self {
                    (value.balance,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCreditBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { balance: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCreditBalanceCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCreditBalanceReturn;
            type ReturnTuple<'a> = (Balance,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCreditBalance(address)";
            const SELECTOR: [u8; 4] = [106u8, 221u8, 27u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCreditStats()` and selector `0xc7d0b56c`.
```solidity
function getCreditStats() external view returns (CreditStats memory stats);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditStatsCall {}
    ///Container type for the return parameters of the [`getCreditStats()`](getCreditStatsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCreditStatsReturn {
        #[allow(missing_docs)]
        pub stats: <CreditStats as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditStatsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCreditStatsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCreditStatsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CreditStats,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <CreditStats as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCreditStatsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCreditStatsReturn) -> Self {
                    (value.stats,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCreditStatsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stats: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCreditStatsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCreditStatsReturn;
            type ReturnTuple<'a> = (CreditStats,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCreditStats()";
            const SELECTOR: [u8; 4] = [199u8, 208u8, 181u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeCredit(address,address)` and selector `0xa84a1535`.
```solidity
function revokeCredit(address from, address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_0Call {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeCredit(address,address)`](revokeCredit_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_0Call) -> Self {
                    (value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeCredit_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeCredit_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeCredit_0Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeCredit_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeCredit(address,address)";
            const SELECTOR: [u8; 4] = [168u8, 74u8, 21u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeCredit(address)` and selector `0xa8ef8caf`.
```solidity
function revokeCredit(address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_1Call {
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeCredit(address)`](revokeCredit_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_1Call) -> Self {
                    (value.to,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeCredit_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { to: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeCredit_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeCredit_1Call {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeCredit_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeCredit(address)";
            const SELECTOR: [u8; 4] = [168u8, 239u8, 140u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeCredit(address,address,address)` and selector `0xd188931d`.
```solidity
function revokeCredit(address from, address to, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_2Call {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub caller: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeCredit(address,address,address)`](revokeCredit_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCredit_2Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_2Call) -> Self {
                    (value.from, value.to, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeCredit_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        caller: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCredit_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeCredit_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeCredit_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeCredit_2Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeCredit_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeCredit(address,address,address)";
            const SELECTOR: [u8; 4] = [209u8, 136u8, 147u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAccountSponsor(address,address)` and selector `0x7da4cb59`.
```solidity
function setAccountSponsor(address from, address sponsor) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAccountSponsorCall {
        #[allow(missing_docs)]
        pub from: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub sponsor: ::alloy_sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setAccountSponsor(address,address)`](setAccountSponsorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAccountSponsorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use ::alloy_sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAccountSponsorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAccountSponsorCall) -> Self {
                    (value.from, value.sponsor)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAccountSponsorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        sponsor: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAccountSponsorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAccountSponsorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAccountSponsorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAccountSponsorCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAccountSponsorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAccountSponsor(address,address)";
            const SELECTOR: [u8; 4] = [125u8, 164u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ICreditFacade`](self) function calls.
    pub enum ICreditFacadeCalls {
        #[allow(missing_docs)]
        approveCredit_0(approveCredit_0Call),
        #[allow(missing_docs)]
        approveCredit_1(approveCredit_1Call),
        #[allow(missing_docs)]
        approveCredit_2(approveCredit_2Call),
        #[allow(missing_docs)]
        approveCredit_3(approveCredit_3Call),
        #[allow(missing_docs)]
        buyCredit_0(buyCredit_0Call),
        #[allow(missing_docs)]
        buyCredit_1(buyCredit_1Call),
        #[allow(missing_docs)]
        getAccount(getAccountCall),
        #[allow(missing_docs)]
        getCreditApproval(getCreditApprovalCall),
        #[allow(missing_docs)]
        getCreditBalance(getCreditBalanceCall),
        #[allow(missing_docs)]
        getCreditStats(getCreditStatsCall),
        #[allow(missing_docs)]
        revokeCredit_0(revokeCredit_0Call),
        #[allow(missing_docs)]
        revokeCredit_1(revokeCredit_1Call),
        #[allow(missing_docs)]
        revokeCredit_2(revokeCredit_2Call),
        #[allow(missing_docs)]
        setAccountSponsor(setAccountSponsorCall),
    }
    #[automatically_derived]
    impl ICreditFacadeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 233u8, 139u8, 250u8],
            [3u8, 14u8, 213u8, 72u8],
            [106u8, 221u8, 27u8, 63u8],
            [125u8, 164u8, 203u8, 89u8],
            [142u8, 78u8, 111u8, 6u8],
            [163u8, 142u8, 174u8, 159u8],
            [168u8, 74u8, 21u8, 53u8],
            [168u8, 239u8, 140u8, 175u8],
            [178u8, 125u8, 140u8, 2u8],
            [199u8, 208u8, 181u8, 108u8],
            [205u8, 155u8, 232u8, 15u8],
            [209u8, 136u8, 147u8, 29u8],
            [241u8, 214u8, 237u8, 100u8],
            [251u8, 203u8, 192u8, 241u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ICreditFacadeCalls {
        const NAME: &'static str = "ICreditFacadeCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::approveCredit_0(_) => {
                    <approveCredit_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approveCredit_1(_) => {
                    <approveCredit_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approveCredit_2(_) => {
                    <approveCredit_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approveCredit_3(_) => {
                    <approveCredit_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::buyCredit_0(_) => {
                    <buyCredit_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::buyCredit_1(_) => {
                    <buyCredit_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAccount(_) => {
                    <getAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCreditApproval(_) => {
                    <getCreditApprovalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCreditBalance(_) => {
                    <getCreditBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCreditStats(_) => {
                    <getCreditStatsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeCredit_0(_) => {
                    <revokeCredit_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeCredit_1(_) => {
                    <revokeCredit_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeCredit_2(_) => {
                    <revokeCredit_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAccountSponsor(_) => {
                    <setAccountSponsorCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ICreditFacadeCalls>] = &[
                {
                    fn approveCredit_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <approveCredit_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::approveCredit_0)
                    }
                    approveCredit_0
                },
                {
                    fn approveCredit_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <approveCredit_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::approveCredit_1)
                    }
                    approveCredit_1
                },
                {
                    fn getCreditBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <getCreditBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::getCreditBalance)
                    }
                    getCreditBalance
                },
                {
                    fn setAccountSponsor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <setAccountSponsorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::setAccountSponsor)
                    }
                    setAccountSponsor
                },
                {
                    fn buyCredit_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <buyCredit_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::buyCredit_0)
                    }
                    buyCredit_0
                },
                {
                    fn buyCredit_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <buyCredit_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::buyCredit_1)
                    }
                    buyCredit_1
                },
                {
                    fn revokeCredit_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <revokeCredit_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::revokeCredit_0)
                    }
                    revokeCredit_0
                },
                {
                    fn revokeCredit_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <revokeCredit_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::revokeCredit_1)
                    }
                    revokeCredit_1
                },
                {
                    fn approveCredit_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <approveCredit_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::approveCredit_2)
                    }
                    approveCredit_2
                },
                {
                    fn getCreditStats(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <getCreditStatsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::getCreditStats)
                    }
                    getCreditStats
                },
                {
                    fn getCreditApproval(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <getCreditApprovalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::getCreditApproval)
                    }
                    getCreditApproval
                },
                {
                    fn revokeCredit_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <revokeCredit_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::revokeCredit_2)
                    }
                    revokeCredit_2
                },
                {
                    fn approveCredit_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <approveCredit_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::approveCredit_3)
                    }
                    approveCredit_3
                },
                {
                    fn getAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ICreditFacadeCalls> {
                        <getAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ICreditFacadeCalls::getAccount)
                    }
                    getAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::approveCredit_0(inner) => {
                    <approveCredit_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approveCredit_1(inner) => {
                    <approveCredit_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approveCredit_2(inner) => {
                    <approveCredit_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approveCredit_3(inner) => {
                    <approveCredit_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::buyCredit_0(inner) => {
                    <buyCredit_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::buyCredit_1(inner) => {
                    <buyCredit_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAccount(inner) => {
                    <getAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getCreditApproval(inner) => {
                    <getCreditApprovalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCreditBalance(inner) => {
                    <getCreditBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCreditStats(inner) => {
                    <getCreditStatsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeCredit_0(inner) => {
                    <revokeCredit_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeCredit_1(inner) => {
                    <revokeCredit_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeCredit_2(inner) => {
                    <revokeCredit_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAccountSponsor(inner) => {
                    <setAccountSponsorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::approveCredit_0(inner) => {
                    <approveCredit_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approveCredit_1(inner) => {
                    <approveCredit_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approveCredit_2(inner) => {
                    <approveCredit_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approveCredit_3(inner) => {
                    <approveCredit_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::buyCredit_0(inner) => {
                    <buyCredit_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::buyCredit_1(inner) => {
                    <buyCredit_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAccount(inner) => {
                    <getAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCreditApproval(inner) => {
                    <getCreditApprovalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCreditBalance(inner) => {
                    <getCreditBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCreditStats(inner) => {
                    <getCreditStatsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeCredit_0(inner) => {
                    <revokeCredit_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeCredit_1(inner) => {
                    <revokeCredit_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeCredit_2(inner) => {
                    <revokeCredit_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAccountSponsor(inner) => {
                    <setAccountSponsorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ICreditFacade`](self) events.
    pub enum ICreditFacadeEvents {
        #[allow(missing_docs)]
        CreditApproved(CreditApproved),
        #[allow(missing_docs)]
        CreditDebited(CreditDebited),
        #[allow(missing_docs)]
        CreditPurchased(CreditPurchased),
        #[allow(missing_docs)]
        CreditRevoked(CreditRevoked),
    }
    #[automatically_derived]
    impl ICreditFacadeEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                92u8,
                193u8,
                181u8,
                40u8,
                97u8,
                67u8,
                201u8,
                209u8,
                248u8,
                225u8,
                192u8,
                144u8,
                181u8,
                215u8,
                48u8,
                35u8,
                136u8,
                171u8,
                148u8,
                251u8,
                69u8,
                177u8,
                225u8,
                142u8,
                99u8,
                216u8,
                176u8,
                142u8,
                248u8,
                192u8,
                247u8,
                195u8,
            ],
            [
                172u8,
                242u8,
                189u8,
                201u8,
                150u8,
                150u8,
                218u8,
                53u8,
                203u8,
                254u8,
                48u8,
                14u8,
                139u8,
                125u8,
                61u8,
                51u8,
                127u8,
                252u8,
                153u8,
                24u8,
                216u8,
                84u8,
                124u8,
                88u8,
                239u8,
                139u8,
                88u8,
                162u8,
                14u8,
                192u8,
                117u8,
                223u8,
            ],
            [
                198u8,
                151u8,
                9u8,
                230u8,
                247u8,
                103u8,
                218u8,
                215u8,
                204u8,
                177u8,
                156u8,
                96u8,
                92u8,
                60u8,
                96u8,
                43u8,
                244u8,
                130u8,
                236u8,
                180u8,
                38u8,
                5u8,
                157u8,
                124u8,
                219u8,
                94u8,
                87u8,
                55u8,
                208u8,
                91u8,
                34u8,
                248u8,
            ],
            [
                230u8,
                61u8,
                26u8,
                144u8,
                92u8,
                12u8,
                188u8,
                127u8,
                37u8,
                200u8,
                247u8,
                26u8,
                245u8,
                236u8,
                183u8,
                68u8,
                183u8,
                113u8,
                178u8,
                15u8,
                149u8,
                79u8,
                57u8,
                225u8,
                101u8,
                77u8,
                77u8,
                131u8,
                143u8,
                147u8,
                184u8,
                158u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ICreditFacadeEvents {
        const NAME: &'static str = "ICreditFacadeEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<CreditApproved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CreditApproved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CreditApproved)
                }
                Some(<CreditDebited as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CreditDebited as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CreditDebited)
                }
                Some(<CreditPurchased as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CreditPurchased as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CreditPurchased)
                }
                Some(<CreditRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CreditRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CreditRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ICreditFacadeEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CreditApproved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CreditDebited(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CreditPurchased(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CreditRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CreditApproved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CreditDebited(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CreditPurchased(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CreditRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
}
