//! Partially copied from https://github.com/foundry-rs/foundry/blob/60f0b692acae47a4933bb4a0bc4a29cab8831ba1/crates/sol-macro-gen/src/sol_macro_gen.rs
//!
//! SolMacroGen and MultiSolMacroGen
//!
//! This type encapsulates the logic for expansion of a Rust TokenStream from Solidity tokens. It
//! uses the `expand` method from `alloy_sol_macro_expander` underneath.
//!
//! It holds info such as `path` to the ABI file, `name` of the file and the rust binding being
//! generated, and lastly the `expansion` itself, i.e the Rust binding for the provided ABI.
//!
//! It contains methods to read the json abi, generate rust bindings from the abi and ultimately
//! write the bindings to a crate or modules.
//!
//! SPDX-License-Identifier: Apache-2.0, MIT

use alloy_sol_macro_expander::expand::expand;
use alloy_sol_macro_input::{SolInput, SolInputKind};
use eyre::{Context, Result};
use proc_macro2::{Span, TokenStream};
use std::{
    fmt::Write,
    path::{Path, PathBuf},
};

use crate::forge::fs;

pub struct SolMacroGen {
    pub path: PathBuf,
    pub name: String,
    pub expansion: Option<TokenStream>,
}

impl SolMacroGen {
    pub fn new(path: PathBuf, name: String) -> Self {
        Self {
            path,
            name,
            expansion: None,
        }
    }

    pub fn get_sol_input(&self) -> Result<SolInput> {
        let path = self.path.to_string_lossy().into_owned();
        let name = proc_macro2::Ident::new(&self.name, Span::call_site());
        let tokens = quote::quote! {
            #name,
            #path
        };

        let sol_input: SolInput = syn::parse2(tokens).wrap_err("failed to parse input")?;

        Ok(sol_input)
    }
}

pub struct MultiSolMacroGen {
    pub instances: Vec<SolMacroGen>,
}

impl MultiSolMacroGen {
    pub fn new(instances: Vec<SolMacroGen>) -> Self {
        Self { instances }
    }

    pub fn generate_bindings(&mut self) -> Result<()> {
        for instance in &mut self.instances {
            Self::generate_binding(instance).wrap_err_with(|| {
                format!(
                    "failed to generate bindings for {}:{}",
                    instance.path.display(),
                    instance.name
                )
            })?;
        }

        Ok(())
    }

    fn generate_binding(instance: &mut SolMacroGen) -> Result<()> {
        let input = instance.get_sol_input()?.normalize_json()?;

        let SolInput {
            attrs: _,
            path: _,
            kind,
        } = input;

        let tokens = match kind {
            SolInputKind::Sol(mut file) => {
                let sol_attr: syn::Attribute = syn::parse_quote! {
                    #[sol()]
                };
                file.attrs.push(sol_attr);
                expand(file).wrap_err("failed to expand")?
            }
            _ => unreachable!(),
        };

        instance.expansion = Some(tokens);
        Ok(())
    }

    pub fn write_to_module(&mut self, bindings_path: &Path, single_file: bool) -> Result<()> {
        self.generate_bindings()?;

        let _ = fs::create_dir_all(bindings_path);

        let mut mod_contents = r#"#![allow(unused_imports, clippy::all, rustdoc::all)]
        //! This module contains the sol! generated bindings for solidity contracts.
        //! This is autogenerated code.
        //! Do not manually edit these files.
        //! These files may be overwritten by the codegen system at any time.
        "#
        .to_string();

        for instance in &self.instances {
            let name = instance.name.to_lowercase();
            if !single_file {
                // Module
                write_mod_name(&mut mod_contents, &name)?;
                let mut contents = String::new();

                write!(contents, "{}", instance.expansion.as_ref().unwrap())?;
                let file = syn::parse_file(&contents)?;

                let contents = prettyplease::unparse(&file);
                fs::write(bindings_path.join(format!("{name}.rs")), contents)
                    .wrap_err("Failed to write file")?;
            } else {
                // Single File
                let mut contents = String::new();
                write!(contents, "{}\n\n", instance.expansion.as_ref().unwrap())?;
                write!(mod_contents, "{contents}")?;
            }
        }

        let mod_path = bindings_path.join("mod.rs");
        let mod_file = syn::parse_file(&mod_contents)?;
        let mod_contents = prettyplease::unparse(&mod_file);

        fs::write(mod_path, mod_contents).wrap_err("Failed to write mod.rs")?;

        Ok(())
    }
}

fn write_mod_name(contents: &mut String, name: &str) -> Result<()> {
    if syn::parse_str::<syn::Ident>(&format!("pub mod {name};")).is_ok() {
        write!(contents, "pub mod {name};")?;
    } else {
        write!(contents, "pub mod r#{name};")?;
    }
    Ok(())
}
